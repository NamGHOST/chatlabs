Below is a more general strategy for handling any arbitrary action from the LLM, rather than having case by case logic (e.g. “click,” “navigate,” “likePosts,” etc.). Essentially, we’ll collect and forward any “EXECUTE:{…}” payload to the content script and let the content script parse and run it as best it can. You can add as many utilities as you’d like in that content script—scrolling, clicking, etc.—without needing to expand a big switch/case in the background script each time.

────────────────────────────────────────────────────────

1) Consolidated “EXECUTE_ANY” Action

────────────────────────────────────────────────────────

In the background.js, replace your various switch cases with a single “EXECUTE_ANY” case. For example:

```language:file_path

// ... existing code ...

switch (action.type) {

- case 'click':
- // old logic for click
- break;
- case 'screenshot':
- // old logic for screenshot
- break;
- // etc …

+   default:

+       // Instead of separate cases, pass everything to the content script

+       console.log('[executeAction] Forwarding to content script:', action);

+       await injectContentScript(tab.id);  // ensure content script is loaded

+       const response = await chrome.scripting.executeScript({

+           target: { tabId: tab.id },

+           func: (actionObject) => {

+               // This function runs in page context, all logic lives in content.js

+               return window.__universalAction?.(actionObject) ?? {

+                   success: false,

+                   error: 'No universalAction function found on window.'

+               };

+           },

+           args: [action]

+       });

+       return { success: true, data: response[0].result };

}

// ...

```
// ... existing code ...
switch (action.type) {
-   case 'click':
-       // old logic for click
-       break;
-   case 'screenshot':
-       // old logic for screenshot
-       break;
-   // etc …

+   default:
+       // Instead of separate cases, pass everything to the content script
+       console.log('[executeAction] Forwarding to content script:', action);
+       await injectContentScript(tab.id);  // ensure content script is loaded
+       const response = await chrome.scripting.executeScript({
+           target: { tabId: tab.id },
+           func: (actionObject) => {
+               // This function runs in page context, all logic lives in content.js
+               return window.__universalAction?.(actionObject) ?? {
+                   success: false,
+                   error: 'No universalAction function found on window.'
+               };
+           },
+           args: [action]
+       });
+       return { success: true, data: response[0].result };
}
// ...
```

Now anything that arrives (e.g. “{"type": "navigate", "url": "https://www.threads.net"}” or “{"type": "likePosts", "numPosts": 5}”) will be forwarded to the content script, calling a single universal function (e.g. window.__universalAction) with that entire object. Feel free to keep a couple of “core” Chrome-level actions (like screenshot) that must happen in a service worker (because content scripts can’t do certain Chrome APIs directly). But for everything that can be done in the page context (scroll, click, sign in, parse data, etc.), forward it to a single place.────────────────────────────────────────────────────────2) Move Action-Specific Logic to Content Script────────────────────────────────────────────────────────In your content.js, define a global function (or set of functions) that can interpret the JSON action and do the right thing. For example:javascript:chatbot-ui-extension/content.js

// At the top of content.js

window.**universalAction = async function(action) {**

try {

switch (action.type) {

case 'navigate':

window.location.href = action.url;

return { success: true, message: Navigating to ${action.url} };

case 'click':

// If x,y are given, click at that coordinate, else if there’s a selector, etc.

if (action.x != null && action.y != null) {

const element = document.elementFromPoint(action.x, action.y);

if (element) {

element.click();

return { success: true, message: 'Clicked element at coords.' };

} else {

return { success: false, error: 'No element at those coords.' };

}

}

return { success: false, error: 'No coords/selector provided for click.' };

case 'likePosts':

// Same logic you had that finds “like” buttons, scrolls, etc.

let count = 0;

const numPosts = action.numPosts || 5;

for (let round = 0; round < 5; round++) {

count += clickLikes(numPosts - count);

if (count >= numPosts) break;

window.scrollBy(0, window.innerHeight);

await new Promise(r => setTimeout(r, 1000));

}

return { success: true, liked: count };

// ...

// Add more cases, or fallback:

default:

return { success: false, error: Unknown type: ${action.type} };

}

} catch (err) {

return { success: false, error: 'Error in universalAction: ' + err.message };

}

};

// example helper

function clickLikes(maxCount) {

if (!maxCount) return 0;

let c = 0;

const likeButtons = document.querySelectorAll('button, a');

for (const btn of likeButtons) {

const label = (btn.innerText || btn.getAttribute('aria-label') || '').toLowerCase();

if (label.includes('like')) {

btn.click();

c++;

if (c >= maxCount) break;

}

}

return c;

}

Here, your LLM can produce any type: “navigate”, “scroll”, “likePosts”, etc. as a JSON structure. The background service worker passes it to the content script, which uses a single universal function to interpret it.

────────────────────────────────────────────────────────
3) AI Output Example
────────────────────────────────────────────────────────

When the AI says something like:

“EXECUTE:{
"type":"likePosts",
"url":"[https://www.threads.net](https://www.threads.net/)",
"numPosts":5
}”

Your background script sees that “EXECUTE” line, calls executeAction({ type: "likePosts", "url": "[https://www.threads.net](https://www.threads.net/)", "numPosts":5 }), and the default case just says:

• inject content script

• call window.__universalAction(action)

• let that function do the rest

────────────────────────────────────────────────────────
4) Why This is More “All-Around”
────────────────────────────────────────────────────────

By forwarding all logic to the content script:

- You can add new commands without editing background.js repeatedly.

• The LLM can produce anything that the content script knows how to handle.

• If an incoming action is truly brand new or not recognized, you can respond with “Unknown type.”

This centralizes all page-level automations in one place (content.js). The only time you still might have to handle special logic in the background script is if you need a Chrome API that cannot be run from the content script (e.g. capturing a screenshot via chrome.tabs.captureVisibleTab, or working with filesystem, etc.). In that case, you can keep a minimal fallback in the background script:

js
switch (action.type) {
case 'screenshot':
// do screenshot here
break;
default:
// everything else -> content script
}

────────────────────────────────────────────────────────
5) Letting the LLM Do “Anything”
────────────────────────────────────────────────────────

With this approach, you’re mostly giving the LLM a universal interface. If you refine window.__universalAction with new capabilities—like “scroll to bottom,” “wait for selector,” “fill input,” “click button with text X,” etc.—the LLM can just produce an EXECUTE block calling those. You don’t have to expand a big switch in your background script for each new command.

You will still want to:

- Maintain sanity checks: the LLM might produce invalid or harmful commands.

• Possibly manage user permissions or a user confirmation flow if you’re concerned about untrusted code.

But from an engineering standpoint, you no longer need a separate “case 'likePosts': do stuff” for every single new action type.

────────────────────────────────────────────────────────
Conclusion
────────────────────────────────────────────────────────

This single “EXECUTE_ANY” approach in the background script—forwards all requests to the content script—lets you remain flexible. The content script can keep a single “universalAction” function that maps each action type to the appropriate real logic (clicking, navigating, scrolling, etc.). If you want more advanced logic, you add it in content.js. You’ll never have to update background.js for each new action again.